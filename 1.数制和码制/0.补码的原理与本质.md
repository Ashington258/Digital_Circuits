从前有一群异想天开的欧洲人，整天想能不能用机器来思考问题。他们发现生活中的很多问题都可以转换成加法，本着征服了国王的女人就征服了天下的原则，他们想到只要能做出一个能计算加法的机器就可以了。

这个东西并不难做，找一堆电池导线和灯泡就可以，难的是这玩意是不是真的什么问题都能解决。很快就有人站出来问这玩意怎么做减法？

这个问题把大家都难住了，加法和减法这两个完全相反的东西怎么能用同一方法计算呢？减法的目的是要让一个数字变小，而加法只能让它变大。

这帮家伙苦思不得其解。有人想改进原来的电路，有人想重新设计一个专门算减法的电路。这些方案都存在这样那样的问题，所有的人都在想寻找一个完美的解决办法。

这天一个教授在图书馆乱逛，发现了一本中国的成语词典。他随手一翻，找到了一个成语——南辕北辙，讲的是一个应该南下去楚国的人车子却在往北走。这位教授心想这个人好傻，不过要是他一直走下去的话也是能到的，因为地球是圆的嘛。

既然往北走到南方这种看似不可能的事理论上都能实现，那加上一个数让它变小为什么不可以呢。他开始仔细比较这两个问题有什么不一样，很快的除了结论：地球是圆的，但数轴是平的，而且往正负极无限延伸。

他并没有因此而懊恼，既然没有条件那就创造条件嘛，既然数轴是直线，那就截取一段然后首尾相接弯成圆形呗。这样想着他截取了一段0-999的数轴，因为这个自创的数轴是圆的，所以999加1就会变成0而不是1000，这样不就实现了加上一个数还能变小了嘛！

光有灵感是不够的，他还要设计一套完整的计算法则。不过既然规则是由人制定的就意味着可能会有漏洞，我们不得不去讨论所有的情况以确保万无一失，否则只要有一个反例就能让我们辛辛苦苦搭建的高楼轰然倒塌。

他赶紧完善这套自创的计算方法。从0到999一共有1000个整数，所以就称这段数轴的模长为1000。如果要做减法，那么就加上一个数，让结果超过这段数轴能表示的最大的数，这样就不得不从0开始重新计算。也就是说，每当要减去一个数，就要想办法找到应该加上的那个数。比如说模长是1000，那么减去200就可以变成加上800，减去300就可以变成加上700。他发现要减去的数和要加上的数有一种关系，就是他们的和总是1000，这有点像几何里面的补角的概念，所以他就给这两种数分别取了一个名字，要减去的数叫原码，要加上的数叫补码。如果想要减去200，那么要加上的800就是200的补码，如果想减300，那么要加上的700就是300的补码。根据补码的求法可以发现补码是和模的取值有很大关系。

想出了这个办法后他赶紧验证。他随便做一个运算：

694-246=448

那么用补码运算法就应该先寻找要减去的这个数的补码，补码为：

1000-246=754

把减去246转成加上246的补码：

694+754=1448

因为超过了最大能表示的数999，所以取余数：

1448-1000=448

和结果正好吻合！

这个方法似乎有点美中不足，因为它的缺点很明显，他能表示的数是有限制的。也就是说他只能计算结果在0-999这个范围内的运算，如果运算结果超过了这个范围就不对了，我们成为溢出。不过这个长度是随意取的，如果想要进行很大的数据运算的话就把长度取长一点就行了。取0-999就只能进行百位数的运算，取0-9999999的话就可以进行百万位数的运算，不够的话还可以取更大的。这个方法叫做扩增位数。

他赶紧找来一张纸写下了如今长居于我们组原课本里的一句话：

用减法减去一个数可以转换成加上这个数的补码。

到了这里就结束了吗?当然没有，他还要进行很多次试验确认这种方法万无一失。有一个问题很明显，我们在计算补码的时候用的就是减法，用减法将减法转换成加法，听起来就挺讽刺。

那该怎么解决呢？这就要回到书本上让人匪夷所思的二进制了。我们都知道二进制里只有两个数字0和1，正是因为这样的特性让它不用减法也可以进行求补运算。比如在二进制数轴上取0-11111111这一段，那么模长就是100000000。

随便找一个数10110010求补码：

100000000-10110010=01001110

刚刚不是说不用减法了吗，为什么还在减呢？先别急，我们换一个思路来理解。100000000可以看成11111111加1，也就是说上面求补码的过程可以转换成：

100000000-10110010  
\=11111111+1-10110010  
\=11111111-10110010+1  
\=01001101+1  
\=01001110

大家一看还是有减法啊，治标不治本嘛！别急，这个减法有点特殊，被减数是11111111，我们只要把减数里的1全部换成0，0全部换成1就行了。过程叫做取反，得到的结果叫做反码。因为被减数减了1，所以结果要加上1，这就是为什么书上总是说补码的求法是取反加一。

通过这个方法就可以不借助减法也能求补了，多亏了几百年前莱布尼茨发明了这种神奇的计数进制，真可谓前人种树后人乘凉。

他欣喜若狂地想要将这个方法应用到实践中去，直到他开始用这种方法计算自己的工资。

有一次他刚刚拿到薪水就考虑出国度假，但是预算不足所以超支了，他想算算看自己超了预算多少，结果算出来的结果却让他大跌眼镜。算出来的结果竟然是正数？

看来革命尚未成功，也不能高兴地太早。这个问题不太容易发现，那就是结果是负数的情况，举个例子：

300-700=-400

如果他继续用自己发明的方法计算的话就要先求减数的补码：

1000-700=300

然后将减法转换成加法：

300+300=600

因为没有超过模长所以不用进行求余运算，最后的结果就是600，计算得到的答案和真实的答案不一样。

于是它又陷入了郁闷，看来自己设计出来的运算方法不能适用于所有的情况。他开始寻找错误的原因，先来看看计算得到的答案和真实结果的关系。600和-400刚好相差1000，又是这个1000。上一次我们用到1000的地方是求补的时候，仔细一看，600不是正好可以理解为-400的补码吗！

柳暗花明又一村。原来答案没有错，只是对答案的理解方式有错，他得到的不是结果本身，而是结果的补码。于是他把补码的适用范围从减数扩展到减数和差。那么他很容易就联想到了是不是被减数也可以用补码来表示？当然可以，举个例子：

\-300-400=-700

对400求补码：

1000-400=600

对300求补码：

1000-300=700

原式转换成：

600+700=1300  
1300-1000=300

而300恰好是-700的补码。虽然看着有点奇怪，但从某种意义上来讲确实算出了答案。

于是他又在刚刚那句话下面加了一句话：

所有的数都应该用补码来表示，正数的补码是它自身，而负数的补码是取反后加一。

正当他以为问题圆满解决的时候，却没想到自己其实捅了一个更大的篓子，很快他就遇到了麻烦。

我们先计算两道算数题：

100+300=400  
200-800=-600

结果没什么问题，但是用计算机来计算的话会怎么样呢？第一道很简单，甚至不需要补码转换，直接加就好。第二道的话因为涉及到减法所以要进行补码转换，-800的补码是200，所以转换成：

200+200=400

按照之前的理解，400是-600的补码，答案并没有任何问题，但是这是在知道正确答案的情况下我们可以理解计算得到的答案，如果不知道正确答案仅仅得到计算的答案400，它到底是400的原码，还是-600的补码呢？换句话说，-600的补码是400，而400不一定是-600的补码，他可能是400本身的原码。

这下他傻眼了，补码的求法是他自己定义的，正是因为这种求法才会导致所有的结果都会有歧义。他竟然亲手毁了自己的发明。

这是一个无法忽视的问题。求补的方式是我们自己定义的，如果要改变求补的方式就要把之前的工作全部推倒重来，否则就必须找到一种能够区分正负数的办法。为了不让之前的努力变为沉没成本，他决定继续往前走。

人们在数字前面加上一个+表示正数，加上一个-表示负数，本质上只是一种区分用的符号，是人为规定的。只要我们愿意的话，也可以自己规定在数字前面加-表示正数，加+表示负数。对于只认死理计算机来说，除了0和1以外一概不认。同样非此即彼的特性倒是有几分相似之处，于是他萌生了用数字表示符号位的念头。

我们规定每个二进制数的第一位为符号位，0为正数1为负数。而后面的所有位都是数值位，和原来的表示方法一样。这样的话我们无论看到什么数都先检查它的第一位确定它的符号，这样就知道该如何解读它。

可是他心里还是有一丝担忧，这样大刀阔斧的改革会不会出问题？毕竟计算机是分不清符号位和数值位的，即便是符号位也会被当做数值位一起运算，万一把正数算成负数，负数算成正数怎么办？

想到这里他已经有点头晕了，他必须好好梳理一下自己的思路。他的目的是想通过加法来表示减法，于是他发明了一个叫做补码的东西。不过这个东西会产生歧义，为了区分正负补码，他决定用一个二进制位表示符号。可是计算机会将符号位当做数值位一起运算，这样做的计算结果会不会导致符号出问题？如果想要证明符号位不会出现错误，就要考虑到所有的情况，并且保证用自己的方法计算出来的结果和真实的结果相同。

他罗列出了一级四则运算所有的情况：

正数+正数=正数  
正数-正数=正数  
正数-正数=负数  
正数+负数=正数（重复）  
正数+负数=负数（重复）  
正数-负数=正数（重复）  
负数+正数=正数（重复）  
负数+正数=负数（重复）  
负数-正数=负数  
负数+负数=负数（重复）  
负数-负数=正数（重复）  
负数-负数=正数（重复）

生活中遇到的所有加减法都可以归结到以上几种情况当中，而这几种情况又有重复。所以只要证明上述四种情况用自己发明的方法运算得到的结果和正确结果一致，那么就可以用自己发明的方法取代原来的方法。

首先我们进行一个运算：

200-200=0

用补码运算法运算：

200+800=1000  
1000-1000=0

这是一个非常特殊的情况，一个数减去它自身等于0。如果减数变大了，结果就会变成负数，减数变小了，结果就会变成正数。而一个数的补码和原码是互补的，原码增大了，补码就会变小，反之亦然。首先看减数变小的情况。

200-100=100

转换成补码运算：

200+900=1100  
1100-1000=100

结果超过了模，所以需要进行求余运算。而减数变大会怎么样呢？

200-300=-100

换成补码运算：

200+700=900

结果没有超过模，所以不需要进行求余运算。于是我们得出了一个结论，当减法的结果为正数，计算过程会发生溢出，并且答案就是原码本身。当结果为负数，则不会发生溢出，但是我们只能得到答案的补码，需要进行求补运算才能得到正确答案。这个特性非常重要，对证明符号位即使参与运算也不会产生错误结果有很大帮助。

正数加正数的情况是这样的：

0xxxxxxx+0xxxxxxx=0xxxxxxx

两个符号位都是0，相加之后仍为0。但是要警惕的一种情况就是数值运算的结果溢出产生进位到符号位改变符号位。这种情况的解决办法就是扩增位数使得进位无法传到符号位，将符号位“保护”起来。

如果一个正数减另一个正数答案也是正数的话是这种形式：

0xxxxxxx-0xxxxxxx=0xxxxxxx即  
0xxxxxxx+1xxxxxxx=0xxxxxxx

因为答案是正数，所以后面数值位的运算会发生溢出（前面提到的特性）。不过这里的溢出不会再因为模长有限而消失，而是传到了符号位。符号位的运算结果为1，加上数值位的进位变成了10，但是符号位本已经是最高位，它的进位便消失了只剩下0。符号位便“阴差阳错”地得到了正确的结果。

一个正数减另一个正数为负数的情况呢？它的形式是这样的：

0xxxxxxx-0xxxxxxx=1xxxxxxx即  
0xxxxxxx+1xxxxxxx=1xxxxxxx

因为结果为负数，所以不会产生溢出，那么数值位的运算结果也不会产生到符号位的进位。符号位运算的结果也刚好符合我们假设的情况。

最后一种情况是负数减正数：

1xxxxxxx-0xxxxxxx=1xxxxxxx即  
1xxxxxxx+1xxxxxxx=1xxxxxxx

这样的情况两个加数的符号位都是1，他们的和应该是10去掉进位也就是0，也就是说计算的结果是正数，但是负数加负数是不可能为正数的，所以这种情况要讨论。两个负数相加，如果结果不会溢出，这说明他们的补码之和一定会溢出，产生进位到符号位，使符号位变回1。如果两个负数和会溢出，那么他们的补码之和就不会溢出，无法产生进位纠正符号位的错误。这时候就得再次用到扩增位数的方法，保证他们的和不会溢出而补码和会溢出。

到此为止我们终于解决了补码的运算问题，总结一下的话就是：

1.所有的数都以补码的形式保存，正数的补码是它自身，负数的补码为绝对值取反加一。

2.每一个数前面都要加上一个符号位，0表示正数，1表示负数。

3.减去一个数可以转换成加上求补之后的减数。

tip1：补码和求补是两回事，补码表示的是一种存储数据的方法，而求补是一种运算，千万不能弄混。

tip2：对于计算机来说，加上一个正数和减去一个负数的运算原理不同。前一种情况可以直接相加，而后一种情况需要对减数进行求补然后相加，多了一个运算步骤。

以上是我个人对于补码的一点浅薄理解，如有不对之处欢迎指正，谢谢。

一、序言

第一版答案写于2016年8月，当时我正试图理解补码规则的逻辑，并用结果写了一篇回答发在知乎和公众号上，因为收到的回复很乐观，让我一度认为已经把握问题的全貌。事实上答案在符号位的论述上存在谬误，多亏知友在回复中指出，为此我进行了更深入的思考，重新编辑此答案，希望能更接近问题的本原。

二、重温运算规则

首先我想把整套关于原码反码补码的运算规则准确清晰地写一遍，方便急需应用的知友参考，也希望大家首先能记住这套规定，再开始进一步的探讨。

所谓原码就是机器数，是加了一位符号位的二进制数，正数符号位为0，负数符号位为1，计算机中存储、处理、运算的数据通常是8位、16位、32位或64位的，这里以最简单的8位为例讲解。注意符号位是包含在8位中的其中1位，故可直观读出的数只有7位（只有后7位数可以按权展开）。有心人可能注意到原码是有缺陷的，它只能表示255种状态，因为00000000（＋0）和10000000（－0）其实是一个数，因此原码的表示范围成了－127到＋127，这个问题需要神奇的补码来解决，因为在补码中10000000被用来表示－128。

所谓反码，英语里又叫ones' complement（对1求补），这里的1，本质上是一个有限位计数系统里所能表示出的最大值，在8位二进制里就是11111111，在1位十进制里就是9，在3位十六进制里就是FFF（再大就要进位了）。求反又被称为对一求补，用最大数减去一个数就能得到它的反，很容易看出在二进制里11111111减去任何数结果都是把这个数按位取反，0变1，1变零，所以才称之为反码。用原码求反码的方法是，正数不变，负数保留符号位1不变，剩下位按位取反。

所谓补码，英语里又叫two's complement（对2求补），这个2指的是计数系统的容量（模），就是计数系统所能表示的状态数。对1位二进制数来说只有0和1两种状态，所以模是10也就是十进制的2，对7位二进制数来说就是10000000，这个模是不可能取到的，因为位数多一位。用模减去一个数（无符号部分）就能得到这个数的补，比如10000000－1010010=0101110，事实上因为10000000=1111111+1，稍加改变就成了（1111111－1010010）+1，所以又可以表述为先求反再加1。总结求补码的方法就是正数依旧不变，负数保留符号位不变，先求反码再加上1。

记住了怎么求补码，接下来讲讲运算。通过原码的符号位和数值，我们能迅速指出它代表的数，判断其正负并进行四则运算，相比而言反码和补码对于人则显得过于晦涩。如果说原码是给人看的数字语言，那么补码就是计算机的数字语言。计算机不需要知道什么是正负、大小，这些判断对它而言过于复杂。事实上它存储、处理、传输的数都只有补码一种形式，人所做的加减乘除，在计算机里只通过相加和移位就能解决，这都来自于补码系统的内在自洽和巧夺天工的神奇魔力，也是后文要阐述的重点。

对加法和减法，按上文的方法求得补码之后，直接相加就可以了，但相加的时候符号位一定要一起参与运算，有时候，两符号位相加或者接受来自低位的进位会发生溢出，就扔掉溢出的一位（稍后会解释为什么），由新的符号位决定结果的正负，如果是0表示正数，结果就是原码，如果是1表示负数，结果还要再求补数得到原码。

至此我介绍了原码反码补码的规定，以及如何求补码并进行加减法（乘除暂不涉及，事实上懂了加减法的奥秘，乘除很容易理解），对于一个工程人才来说，上面的内容已经足够应付所有具体问题。剩下的则是一些“无用”的思考，关于为何这套法则能够化减为加，以及人为规定的符号位在运算中为何总是能精确地指示结果的符号。

三、无用之用

数字是用来记录现实世界数量属性的语言。

而任何计数系统都必须有两个参数：**容量**和**精度**。

**模**是衡量计数系统**容量**的参数。模代表了计数系统所能表示和存储的状态数。

任何有限的计数系统都有一个确定的模。如时钟的模是12（即只有一个位的十二进制系统，若再加一个大钟，使小钟转一周大钟加一刻度，就是有两个位的十二进制系统），再比如8位计算机的模是2^8=256D（每一位也可以单独看做一个模为2的计数系统）。

问题一：化减为加

对同一计数系统中的数量可以定义运算如加减，但运算结果超出预设位数时，就要发生溢出，这个溢出其实就是模，是时钟的一整圈（因此丢掉它没有影响），如果进位没有被另一个计数系统接受，结果看似“失真”，本质上是进入了“第二次循环”。

以时钟系统为例：8+7=15D=13（十二进制）>10（十二进制），进位1溢出丢失（除非用另一个时钟接收这个进位），在表盘上（即一位十二进制计数系统中）呈现为3，而8-5=8+(-5)=3也得到了相同结果。这就说明在有限容量的计数系统中，+7和-5是完全相同的，而它们正是关于模12的一对补数。

因此我们在有限的计数系统做了这种定义：**正数补数即为本身，负数A【补】=模-绝对值（A）**。一个数加上另一个数（可以是正数也可以是负数），结果等于加上这个数的补数，若有进位则舍弃进位。这么做的重大意义在于极大地方便了计算机进行数据处理，要知道对人而言减法并非难事，但用门电路实现就复杂得多了，减之前还要判断大小考虑次序。

问题二：符号位参与运算

在8位计算机中，一个字节可以表示256种状态，把字节看做一个钟的话，刻度可以随便标，不如取0点钟为-128，正对的6点钟为0，即存储范围是从-128到127，用二进制补码表示是10000000~01111111（10000000用来表示-128似乎是人为定义的，因为原码无法表示-128，按正常程序更无法求得其补码）。

![](https://pic1.zhimg.com/50/71fcb11dd84c7d666e842be01aebbfdf_720w.jpg?source=1def8aca)

符号位是我认为理解补码的关键所在，也是关于补码最神奇的地方。人类“生硬”地添加了符号位，把256种状态剪成正负两半，还“生硬”地规定-128的补码为10000000，但用补码运算的时候，一切就像“水往低处流”般正确和谐自然：符号位参与运算，接受来自低位的进位，永远能忠实地指示结果的正负。

我举个例子，你们感受一下：

所谓的“负数加负数会变成正数，正数加正数会变成负数”，本质还是在于，计数系统是无法表示超出其取值范围的计算结果的。

120D+120D=01111000B+01111000B=11110000B，符号位的1来自低位进位，指示了结果是负数，所以需要求补得10010000B也就是-16D，放在钟面上就是从120顺时针旋转120格到240的位置，只不过系统最大只取到127，240的位置就是-16的位置，而且-16和240正是关于模256的一对补数。-120D-120D=16D也是一样的道理。在有限的计数系统内，由于位数的限制，发生溢出的情况下无法得到计算真实值，得到的是真实值关于模的补数。

![](https://pic1.zhimg.com/50/d4bfb4c8fa460ef746252d374c3807fd_720w.jpg?source=1def8aca)

看到这里是不是有那么点味道呢，我给你们总结一下：加法都是从低位往高位做的，如果两个数（补码），后七位相加产生了进位，说明

又溢出了一次，每当溢出一次（就是越过了-128这个正负分界点），符号就要反一下，0变1，1变0。符号是1的，说明大得越界了，需要再求个补，用取值范围内的负数表示结果；符号是0的，说明小得越界了，但由于正数的补数就是本身，就不必再求补了。

四、后记

从八月底的初稿到这篇文章，中间经历了差不多四个月的时间，我对于补码问题的认识也经历了困惑到清晰到困惑到再清晰这一过程，其中修改超过十次，思考所花的时间更是不计其数。从参加考试的角度看，我熟记的运算规则早已足够我应付所有题目，但我仍然不愿意半途而废，原因有二：

大一学习线性代数时，曾经挂过科，因为对于定理和公式背后的含义一无所知，而老师也不加讲解，只一味让我们死记做题。虽然很多同学都适应这种所谓的“工科数学学习”，然而这对我而言简直如同梦魇，没有理解内化如何能称得上学习，不过是应付考试然后忘的精光罢了。我很幸运的是，在准备补考时读到了网上广为流传的孟岩老师的文章《理解矩阵》，我记得那是一个冬天的晚上，读完文章后我很兴奋，一直到半夜都睡不着，这是我第一次体会到数学体系的和谐自洽以及数学的深刻性在工程中的巨大威力，从那以后我才逐渐找到了学习数学的乐趣。

《理解矩阵》中有一段话至今我还记得，现摘抄如下：

自从1930年代法国布尔巴基学派兴起以来，数学的公理化、系统性描述已经获得巨大的成功，这使得我们接受的数学教育在严谨性上大大提高。然而数学公理化的一个备受争议的副作用，就是一般数学教育中直觉性的丧失。数学家们似乎认为直觉性与抽象性是矛盾的，因此毫不犹豫地牺牲掉前者。然而包括我本人在内的很多人都对此表示怀疑，我们不认为直觉性与抽象性一定相互矛盾，特别是在数学教育中和数学教材中，帮助学生建立直觉，有助于它们理解那些抽象的概念，进而理解数学的本质。反之，如果一味注重形式上的严格性，学生就好像被迫进行钻火圈表演的小白鼠一样，变成枯燥的规则的奴隶。

“枯燥的规则的奴隶”又何止是在数学教学中出现的呢？如果你在大学工科学习过，你会发现这些人简直遍地都是，拿我在的浙大为例，有的是学生对课程并不理解，单靠考前突击刷题就拿到90分以上的成绩。

正是在这样的情形下，我决定尽我所能重新思考学到的每一个重要知识，并将其中一部分写成文章，一来有助于对思维的梳理，二来也是便于自己将来的回顾，倘若拙作还能对他人也有所帮助，从而使我给世界留下一些微不足道的影响，那真是幸甚了。

> **所有的数学原理，背后都是最简单最自然的思维和道理而已！**

之前写过一篇文章，专门说补码这事，放这里！

我的套路，就是不喜欢讲数学，先看现象，然后讲道理就好！

**1\. 一段代码引发的血案**

在开始讲计算机补码前，我们先看一个简单的C语言代码

```text
#include <stdio.h>

int main(void)
{
    char a,b;
    char c;
    
    a = -100;
    b = -100;
    c = a + b;

    printf("c=%d", c);

    return 0;
}
//question:what is printed in console？
```

这段代码会打印输出什么呢？

## **\-200？？**

## **再猜，再猜，**

猜不到，还不赶快撸代码，直接用Dev C++跑一下，不就行啦。

![](https://picx.zhimg.com/50/v2-077c433df32dd71ec445a7bb847e2034_720w.jpg?source=1def8aca)

肯定是日了鬼了。。。。

**为什么-100+-100=一个正数56？？？？？**

带着这个疑问，让我们开始计算机补码之旅吧！

**2\. 整数编码的图形式演化**

无符号整数，像C语言里的unsinged char/int/short我这里就不过多介绍，简单点说就是二进制与十进制之间的转化计算而已。重点介绍一下有符号数char/int的编码方式：补码，大家在计算机相关书籍上看的，一般是这样的一段话：

> 原码表示法是整数的一种简单的表示法，符号位用0表示正号，用1表示负号，数值一般用二进制形式表示。  
> 整数的反码可由原码得到，如果是正数，则反码与原码一样；如果是负数，则反码是对它的原码（符号位除外）各位取反而得到的。  
> 整数的补码可由原码得到。如果是正数，则补码与原码一样；如果是负数，则补码是在反码基础上，末位加1而得到。

我估计每学一遍，大家都会看一遍这几句话，然后做做练习，基本也就过去了，应付考试嘛，差不多得了。。。。

但是我自己心里可是始终有一个疑惑，始终想不明白当年那些计算机大师，为什么这么设计原码，反码和补码，这样设计必然有其巧夺天工之处。

在一次无意翻到的一本STC单片机的书上，我看到了一张图，就感觉开窍了。

> **所有编码系统的设计，都在追求连续性和唯一性。**  
> **原码，反码和补码的演化，就在不断提高整数编码的这两方面性能。**

不信的话，可以过来，跟我一起用图形解读整数的编码：

**原码：**原码表示法是整数的一种简单的表示法，符号位用0表示正号，用1表示负号，数值一般用二进制形式表示。

![](https://pic1.zhimg.com/50/v2-359c72c3a8e300046ada8e6d718da24b_720w.jpg?source=1def8aca)

原码的二进制码与整数的对应关系图

观察原码的二进制码表示的整数图，我们发现两个bug

> **bug1：存在重复0，分别为00000000和10000000**  
> **bug2：存在两个间断点，分别为**  
> **011111111->10000000，即127突变为-0**  
> **11111111->000000000，即-127突变为+0**

为什么这么关心间断点，因为这涉及到整个范围内的数值连续性，**任何的间断点都会导致溢出问题。所以这个间断点，越少越好！**

然后我们看看**反码**做了什么，这张图会变成什么样？？？

**反码**：整数的反码可由原码得到，如果是正数，则反码与原码一样；如果是负数，则反码是对它的原码（符号位除外）各位取反而得到的。

![](https://picx.zhimg.com/50/v2-b7291eaf983e2c0a3077784ded5649dd_720w.jpg?source=1def8aca)

反码的二进制码与整数的对应图

对比观察反码与原码的二进制码表示的整数图，我们发现这一次取反，使右半边的图形，做了一次翻转，于是bug2中的间断点被修复了，也就是说间断点从2个变成了1个。

> **bug1：依然存在重复0。**  
> **bug2：两个间断点减少到1个，不能再优化了。**

然后我们继续看看**补码**做了什么，这张图又演化变成什么样？

**补码**：整数的补码可由原码得到。如果是正数，则补码与原码一样；如果是负数，则补码是在反码基础上，末位加1而得到。

![](https://pica.zhimg.com/50/v2-f626697aa9768d43974657c7f06b3e5e_720w.jpg?source=1def8aca)

反码的二进制码与整数的对应图

对比观察补码与反码的二进制码整数图，我们发现这一次求补，使右半边的图形，向下移动了1，于是bug1中的重复点消失了，然后最小负整数从-127变成了-128。

于是我们可以看到，原码中的两个bug，通过两次操作，求反（反码）和求补（补码）全部被解决了。

> **bug1：重复0（通过求补干掉了，我认为就是打个补丁而已）。**  
> **bug2：两个间断点减少到1个（通过取反干掉了）。**

然后我们再回看看和理解一下最开头那句话，

> **所有编码系统的设计，都在追求连续性和唯一性。**  
> **反码去掉间断点，提高连续性。补码在反码基础上，去掉重复点，保证唯一性。**

现在看了这三张图，是不是思路更清晰了一点呢？、？

## 3\. 开始慢慢破解血案

破解血案，我们先做一个简单的计算：

在只有加法器的情况下，分别用原码，反码和补码去算一下，下面三个极其弱智的少儿计算题

**1+1**

**1+（-1）**

**（-1）+（-1）**

。。。小心点，这里有坑

![](https://pica.zhimg.com/50/v2-c21b054c9e9ec169f5c2fac9806d09f4_720w.jpg?source=1def8aca)

有小伙伴就要问了，为什么三个运算，只有补码能保证最终结果正确？？？？？

话说，我也在想，为什么这么神奇！！

我们从图上去看就比较容易理解了

**所有的都是二进制求和，那从图中，无非就是x轴叠加，然后看y轴对应什么而已。**

> 先看1+1，不管是原码，反码还是补码，都是1的二进制码横轴叠加，对应y轴为2  
> 再看1+（-1）  
> 原码：1对应1，-1对应中间位置，那两者叠加，肯定是-1向右移1个，也就是-2  
> 反码：1对应1，-1对应末尾位置，那两者叠加，肯定是-1向右移1个，也就是-0  
> 补码：1对应1，-1对应末尾位置，那两者叠加，肯定是-1向右移1个，回到原点是0  
> 再看（-1）+（-1）  
> 原码：-1对应中间位置偏右1位，那两者叠加，肯定是越界返回原点错2个，也就是2  
> 反码：-1对应末尾位置偏左1位，那两者叠加，肯定是越界后末尾偏左2个，也就是-3  
> 补码：1对应1，-1对应末尾位置，那两者叠加，肯定是-1向右移1个，回到原点是-2

我们现在用补码图，去推算前面那个血案代码里的值

首先看-100在图中哪个位置，中间偏右的位置（红色点位置），那两个-100叠加的话，肯定是溢出，溢出后又从原点开始，然后跑到中间偏左位置（绿色点位置），也就是正数范围里，如果仔细计算就会得到结果56。

![](https://picx.zhimg.com/50/v2-c439842b626838615abb398d247e3133_720w.jpg?source=1def8aca)

旅途到此结束，希望能够帮到你！

一个模运算你们能扯这么多有的没的还真是厉害……

\-x\\equiv 2^n-x\\quad(\\rm{mod}\\ 2^n)

将补码视为取反加一的解释：

2^n-\\left(\\sum\_{i=0}^{n-1} a\_i\\cdot2^i\\right)=1+\\left(\\sum\_{i=0}^{n-1} 2^i\\right)-\\left(\\sum\_{i=0}^{n-1} a\_i\\cdot2^i\\right)=1+\\left(\\sum\_{i=0}^{n-1} (1-a\_i)\\cdot2^i\\right)

显然有：

a-b\\equiv a+(2^n-b)\\quad(\\rm{mod}\\ 2^n)

a\\cdot -b\\equiv a \\cdot 2^n+ a\\cdot -b\\equiv a \\cdot (2^n-b)\\quad(\\rm{mod}\\ 2^n)

写补码时可以视最高位为-2^(n-1)其余位为2^i进制直接写的解释：

0\\cdot -2^{n-1}+\\left(\\sum\_{i=0}^{n-2} a\_i\\cdot2^i\\right)\\equiv 0\\cdot 2^{n-1}+\\left(\\sum\_{i=0}^{n-2} a\_i\\cdot2^i\\right)

1\\cdot -2^{n-1}+\\left(\\sum\_{i=0}^{n-2} a\_i\\cdot2^i\\right)\\equiv2^n-2^{n-1}+\\left(\\sum\_{i=0}^{n-2} a\_i\\cdot2^i\\right)\\equiv 1\\cdot 2^{n-1}+\\left(\\sum\_{i=0}^{n-2} a\_i\\cdot2^i\\right)

想象一个时钟，指针指向的数字是计算机存储的数字。给这个数字做加法，就是把指针顺时针拨动；做减法，就是把指针逆时针拨：

![](https://pic1.zhimg.com/50/v2-0ea68b3ec2a633b37cc5440283706c35_720w.jpg?source=1def8aca)

普通表盘

当然，由于表盘大小是有限的（图中的大小是 8），如果拨得太远，指针可能会从两个方向超过 0，也就是发生**上溢**或者**下溢**。上溢时，你得到的数字是期望结果 - 8；下溢时，你得到的数字是期望结果 + 8.**说简洁一点，就是所有的运算结果都会模 8.**

时钟上只有 0 和大于 0 的数字，不能表示负数，这当然很不方便。所以我们保持 0 的位置不动，把 0 左边的一部分数字认为是负数。然后我们还是可以通过顺逆时针的拨动来实现加减法：

![](https://picx.zhimg.com/50/v2-2afa065f335b17d2b8a7352c658ae5c4_720w.jpg?source=1def8aca)

加入负数的表盘——只需要改一下刻度

可以看到，**这个时钟本身的工作方式不需要进行任何改变，就可以产生正确的结果。**加法还是把指针顺时针拨动，减法还是把指针逆时针拨动。而我们使用原先的运算逻辑就可以对新的数字产生正确的运算结果，这说明现在的表盘刻度与原先的刻度具有等价性：也就是 -1 和 7 是等价的，-2 和 6 是等价的，以此类推。

这个现象在概念上叫**同余：因为表盘上所有运算最终都是要模 8 的（不然会被截断），所以模 8 结果相同的数字在这个运算体系中是等价的。比如说 -1 与 7，模 8 都等于 7，所以两者在运算过程中可以相互替代。**正因为如此，我们虽然把表盘上的数字采取了不一样的解释，但是由于新的解释与原先的数字是模 8 同余的，所以运算逻辑不需要进行改变。

现在，我们把表盘上的数字按照 0~7 写成二进制，再来看看：

![](https://picx.zhimg.com/50/v2-8652929349151c8becd23c84e4540d30_720w.jpg?source=1def8aca)

内圈是有符号数字，外圈是数字的补码

——这就是补码。

那这么来定义表盘刻度有什么好处呢？或者说，使用补码来定义负数的二进制表示有什么好处呢？

我们可以发现，我们给表盘中加入负数之后，钟表的运算逻辑没有发生变化，唯一发生变化的是它的刻度。但是**刻度这个东西是是给人来读的，时钟自己不知道自己现在是几。**

**也就是说，有符号数（也就是 -4~3）与无符号数（也就是 0~7）的运算是一样的，处理器不需要知道自己在处理有符号数还是无符号数，直接当做有符号数来处理即可。**有符号数与无符号数之间的区别只是上层对数字的解释，也就是我们到底是把 111 解释为 7 还是 -1。

> 大家肯定背诵过补码的生成方式:'符号位不变,其它位取取加1'. 看起来很简单是不是,但是这是怎么来的呢. 让有百思不得其解.

## 计组中的定义:

之前的补码的定义,在计算机组成原理的课里面是这样定义的. 是一个文字版本的描述. 而且是在原码的基础上来的:

> 补码定义:  
> \- 最高位为符号位. 为0时为正数. 为1时为负数. 这个与原码相同.  
> \- 为正数时,与原码相同.不作任何处理.  
> \- 为负数时,对原码进行如下处理:  
> \- 符号位不变, 其它位取反加1.

这个看起来很完美,定义也很简洁. 没有歧义. 但是为什么是这样呢. 这个就很难思考通透了. 让我们写一下如下编码的相对应关系:

| 原码 | 补码 | 十进制值 | 十六进制 |
| ---- | ---- | -------- | -------- |
| 0000 | 0000 | 0        | 0x0      |
| 0001 | 0001 | 1        | 0x1      |
| 0110 | 0110 | 6        | 0x6      |
| 1011 | 1101 | \-3      | 0xD      |
| 1100 | 1100 | \-4      | 0xC      |

这个很简单,也很好记. 但是为什么是这样.有点迷糊. 而且上面的定义没有直接对补码怎么定义和计算并没有说明. 只给出了**从原码到补码的推导关系.** 当然补码到原码的计算还有一个规则,那就是:

> 从补码还原到原码, 只需要再进行一次相同的操作: 即符号位不变.再把后面相应的位取反加1即可.

是不是很神奇. 似乎揭示了补码的一些原理. 也就是说: 补码与原码的对应关系似乎是对称的. 或者说对一个数进行两次补码操作后可以得到原数本身.

就如上面的`-3`的原码我们定义为了:`1011` , 这个数本身如果你不说他是原码或者是补码你是看不出来它是什么的.

+   你可以把他当原码理解. 那**取反加1**后得到就是补码. 那它就是原码的`-3` 其补码就是: `1101`
+   你也可以把它当补码解. 那**取反加1**后得到就是原码. 那这个原码就是:`1101`即 `-5`
+   或者说`-3`的补码是`-5`,`-5`的补码是`-3`

我们把`-3`看作成数`x` , 数`-5` 看作成`y` , 我们把**取反加1** 这个操作定义为`取补函数`: f

y = f(x) ,

同时: 这个函数有自反性, 即:

x = f^{-1}(y) , 其中f^{-1}()与 f() 的操作步骤一致.

我们发现`-3`的补码实际是用的原码为`-5`的数来表示的. 所以以上的补码实际的公式看起来应该是(当数为负数的时候):

y\_{buma} = - ( 2^{4-1} - |x| ) , ( 其中4为二进制数位数 )

解释一下这个公式.

+   4为二进制数的位数. 这里我们研究的是4位二进制数.
+   上面的负数取补码的时候就是把负数取绝对值.然后用一个最高位为1,其它位为0表示的最大的无符号数来作为取补的`和` , 即 这里的8.
+   综上: `-3`的补码实际上是用的是`-5`这个数的原码值来表示的. 反过来, `-5`的补码是用`-3`的原码表示的.

这里实际只是对补码的转换关系完成一个从描述到公式定义的转换方法而已. 还是没有给出其实际定义. 但是由于自反性, 上面的求补码的方式实际也是换算原码的方式. 换言之.

+   其实际也是 补码的求值过程.
+   **或者说就是补码的定义( 什么是补码的定义,说白了就是拿到一个编码问其表示的值是多少, 那不就是求原码的过程么,既然求补过程与还原过程操作是一样的. 那当然是可以用同一个函数来表示.)**.

上面说了其自反, 没有进一步的论据,我们看一下<深入理解计算机系统> 中的补码是怎么定义的

## CSAPP中的定义:

我们直接给出公式:

B2T\_\\omega (\\vec{x} ) \\doteq -x\_{\\omega -1}\*2^{\\omega -1}+\\sum\_{i=0}^{\\omega -2}x\_i2^i = - ( x\_{\\omega -1}\*2^{\\omega -1} - \\sum\_{i=0}^{\\omega -2}x\_i2^i )

而这个公式与上面的计算补码的操作过程是一样的. 但是这个公式的定义含义与上面的取补操作有些不一样,可以这样理解:

+   如果符号位为正. 那就是一个无符号数的计算过程.
+   如果是一个负数. 那就是用最高符号位的负数去减去原可表示的正数.

* * *

* * *

实际上, 被码的定义与原码求补码过程是相同的. 所以上面的既是定义补码值的公式. 也是原码计算补码的公式.

> 补码的正数为本身这个不解释,后面再慢慢展开. 负数的补码的值. - 其计算过程. 可以把补码看作原码. 然后计算其补码的过程. - 或者也就按其定义, 是把补码计算其原码的过程. (上面说过了这两个操作的自反性) 当是第一种时, 我们很好理解. 就是把一个负数取绝对值. 然后用和 去减它本身就得到了其补数 补数的值就当成其补码的编码了. 第为第二种进, 其实也就是第一种的反向操作. 但是操作过程是一样的. 我们是在对补数直接推导其原码值

以上这些问题, 我们基本搞清楚了补码的定义是什么. 同时也搞明白了怎样计算补码. 那接下来的问题就是: 为什么补码长这样.

## 补码定义猜想:

我们把一个4位数的二进制按数数的方式记录下来:

| 原码               | 补码 | 值  |
| ------------------ | ---- | --- |
| 1000 (注意不是负0) | 1000 | \-8 |
| 1111               | 1001 | \-7 |
| 1110               | 1010 | \-6 |
| 1101               | 1011 | \-5 |
| 1100               | 1100 | \-4 |
| 1011               | 1101 | \-3 |
| 1010               | 1110 | \-2 |
| 1001               | 1111 | \-1 |
| 0000               | 0000 | 0   |
| 0001               | 0001 | 1   |
| 0010               | 0010 | 2   |
| 0011               | 0011 | 3   |
| 0100               | 0100 | 4   |
| 0101               | 0101 | 5   |
| 0110               | 0110 | 6   |
| 0111               | 0111 | 7   |

### 负数加绝对值大于自己的数

我们考虑 -1 + x , 如果x是正数. 那x的符号位一定为0 , 而且其它位一定有不为0 的位.

如果x = 3, 即: 0011 我们拆解一下:

\-1 + 3 = (-1 +1 ) + 2 = 0+2 = 2

这个单纯从十进制的表达式看,好像没有什么. 我们转换为二进制看就有意思了.

(-1 + 1 ) + 2 = (1111 + 0001) + 0010

刚好由于符号位的限制的溢出效应. 1111 + 0001 这个产生一个进位.同时和却变为了0. 如果忽略进位标志的话, 那刚好在相加过程中抵消掉了. 剩下的就只有剩余部分的0010 , 即2.

大家发现没有,**一个含有负数的加法就像两个正数在相加一样自然**. 同理, -2+4这样的式子.也会有把其拆成-2 + 2 + 2这样的抵消剩余部分的效果.那不够抵消怎么办呢.比如:

\-4+2

### 负数加任意正数

这个我们可以把上面的步骤用一个更通用的模型来解释. 数数. (或者说是计数) , 以上表格的内容实际就是从-8即1000这样的初始数开始数数一样. -8加1实际上就是-8往前数一个数到-7是一个意思. 也就是-8+1

我们再观察一下上面的表格中的补码的增长规律. **是从1000到1111**每次增加1的计数. 然后到了1111即-1后.再加1变为了0;然后再加1时,此时可看到又恢复了每次加1的特性.

![](https://picx.zhimg.com/50/v2-a2ba87020a112d8a8a1c9904ca1e05a2_720w.jpg?source=1def8aca)

这个可以很好的用以解释负数 + 正数

### 正数加正数

这个用数数理论实际与负数+正数是一样的. 不用单独解释.

### 负数加负数

这个需要仔细分析一下. 比如 (-1 + -2) ,按数数的理解. 的确可以模型解释上是统一的. 也就是 把-1的表示值减少2, 即: 1111 - 0010 = 1101 , 这个看起来十分正确对吧. 就像倒着数据一样. 但是有问题的是我们使用了减法. 我们得直接用两个数的补码来运算以检验其正确性.

> 也就是说, 从数论的表示来说. A - B , 这个-1+-2 = -1 -2 = -3 , 亦即: -1往前退两格. 这个从计数的原理和结果看都应该是这样. 即: 1101 ,但是直接要从加法的概念上 (-1) + (-2) = (-3) 去解释.我们的补码加法才能 run 起来.

```text
原式: -1 + -2 

竖式:
 1111
+1110
-----
 1101 
```

巧了不是, 与我们想要的一致. 这个数学原理是什么呢.

## 补码原理:

> 到这里正文才刚刚开始. 其实前面数数和进位的符号标记什么的可能对于理解都很有迷惑性. 我们还是回到补码的公式定义本身来. 这里才是问题的本源.

我们再放一遍补码的公式:

![](https://pic1.zhimg.com/50/v2-ea194cb84829602926a751ae21f4faf9_720w.jpg?source=1def8aca)

补码的原始定义.

现在请忘记前面所有的关于补码的一切. 我们从最原始的补码定义开始研究. 我们还是只研究4 Bits的补码.即上面定义中的 w = 4; 我们再来看一次补码的定义.这次我们不数数了. 直接从定义出来.

![](https://pic1.zhimg.com/50/v2-e2cd327665e7785dbb763529045cd13b_720w.jpg?source=1def8aca)

根据公式定义列举出来的编码表

我们不用去想为什么补码定义成这样. 我们根据公式把补码拆分为左边部分和右边部分. 即:

![](https://picx.zhimg.com/50/v2-45bd4c5efca09dec69a5670f26b62b3a_720w.jpg?source=1def8aca)

补码的原始定义的解释

此时一个补码的编码就被拆成了两个部分. 一部分的权重为负.一部分的权重为正. 这个与CSAPP中的定义完全一致.现在我们来表思考其可以表示的数据的最小值和最大值分别是什么.

+   最大值: 肯定是负数部分为0. 正数部分最大. 这样也就是表中的 +7;
+   最小值: 负数部分为最小, 正数部分也为最小(那就是没有.) 也就是 -8+0 = -8 ;
+   计数原理:
+   肯定是从最小值依次加1表示比原来的数大1的一个数. 即上面表中的-8+0 , -8+1 , -8+2 , .... , -8+7
+   \-1过了肯定是0. 那没有-8+8怎么办呢.好办. 直接正负部分都为0即可;
+   然后是正数,也好说. 负数部分为0. 正数部分依次加1即可. 即: 1,2,...., 7

从表示到计数.再到原理是不是很清晰是不是. **一个数的计数表示由正数部分和负数部分表示,其值为负数部分与正数部分相加后的值**.

现在,我们再来看补码的加法原理. 我们上来就看一下最难的负数+负数 的计算原理.

> 其实我们已经从数论的数制定义给出了基本的 负数 + 正数 表示法. 因此 是否是负数相加,还是正数相加. 其实没有区分了.

我们把一个补码表示为: 负数+正数 ,负数部分我们用M 表示, 正数部分用x或者y表示.

比如:

+   **num1 = -7**: -7 = -8 + 1 ,那M = -8 , x = 1
+   **num2 = -6**: -6 = -8 + 2 , 那 M = -8 ,y = 2

那 -7 + -6 怎么计算呢.

我们得明确, 在负数运算溢出的时候. -7 + -6 = -13 = -16 + 3 = 3 ,否则后面的推导无法进行.

( -7 ) + ( -6 ) = (M + 1 ) + (M + 2) = 2M + 3 = 3

> 实际只需要正 数部分与负数部分分开计算即可. 2M 由于负数部分直接相加溢出后. 有效位就直接变为了0.

我们在计算一下: -1 + -2

( -1 ) + ( -2 ) = ( M + 7 ) + ( M + 6 ) = 2M + 13 = 2M + (-M + 5 ) = M + 5 = ( -3 )

这个怎么理解呢.

> 当相加的时候, 数的操作过程我们可以理解为 分别是两个部分的相加.

### 正数位不会溢出的时候.

两个负数相加. 负数部分会溢出. 然后就是直接正数部分相加. 比如上面的 -7 + -6 我们用竖式表示为: 1 0 0 1 +1 0 1 0 \_\_\_\_\_\_\_\_ 0 0 1 1 用补码相加理解就是: 负数部分相加溢出, 直接舍去. 正数部分没有溢出. 按正常的操作即可. 而上面的这个操作过程,正好可以按无符号的两个正数相加理解. 过程过程是一样的. 因为低三位正好没有进位. 刚好可以看作是bit3与 bit2,bit1,bit0 是分开计算的. 而且结果也是我们想要的.

### 正数部分相加会溢出的时候.

正数部分会溢出一个M单位的值到负数位. 然后正数部分还剩下 X与 Y 相加后 mod 8 剩余的部分. 而当正数部分进位到负数位置后. 正数部分的值的含义会发生变化. 就像上面的 -1 + -2一样. 本来正数部分是5. 但是由于进位到了负数部分. 那这个5不是值本身.而是需要用负数部分去减掉它. 即实际上是正数部分表示的值 5的补数 (且是负值) 即: - (8-5) = -3

### 都是正数的时候

> 这个实际就是上面一小节的 正数部分相加会溢出的时候的原理. 单独看这一部分的解释会更清晰一点.

此时与无符号的数的相加没有任何区别. 区别就在于有溢出的时候的理解上. 因为我们定义的正数部分只有 W-1位. 而按普通的加法的时候最高位是可以用来存储最高正数位的进位的. 此时对于进位位的解释是最关键的.

我们现在来看一个加法: 5 + 6 应该等于多少.

+   如果用4bit无符号的数表示 那 5+6 = 11 , 没有超过4bit可以表示的范围. 那直接等于11即可.
+   如果是用有符号的3bit+1bit的方式表示的时候. 3bit能表示的最大正数是7 , 最高位会溢出. 溢出后低三位上面还有多少? 我们演算一下: 11 = 7 + 4 , 即低三位上还有一个4.
+   此时,我们要定义在溢出的时候: 应该是一个什么样的值 . 就像 -3 mod 4 时,应该得 1 还是 还是得-3.
+   根据补码的计数原则我们是希望 7往上计数溢出时得到了是 1000 , 也就是 -8. 再加1时得到 -7,也就是 1001
+   也就是说 7 + 2 我们希望得到 -7 ,此时正数为001 也就是值应该是 符号位(负数位)的1解释为-8时. 那正好是正数位1的补码(的负数)

有了以上的推断: 我们在 5+6 = 11 = 8 + 3 \\Rightarrow -8 + 3 = -5

也就是说: 5+6 应该等于 -5

### 负数部分处理

在相加时, 实际上我们通过以上的推导. 负数位(符号位) 的处理就可以统一起来了. 如果是有奇数个符号位. 那这个就是一个负数. 需要用补码的相关的定义来计算其实际值.

如果是负数位的1的个数为偶数个. (没有, 或者是2个.) 就可以相互抵销. 比如:

\-3 + 4的演算:

```text
   1 1 0 1
+  0 1 0 0
____________
   2 0 0 1    (注意这里的2 可以理解为一个负数的1 ,一个正数的1. 因此刚好可以抵消)
_____________
   0 0 0 1
```

\-7 + -6 的演算

> \-7 + -6 = (-13)= -16 + 3 = 3

```text
   1 0 0 1
+  1 0 1 0
____________
   2 0  1 1  (这里的2可以理解为两个 负数: -8 ,根据溢出后的和的取整方向我们可以直接舍去取正数部分)
____________
   0 0  1 1
```

## 总结

我们可以单纯的以补码的定义的形式进行计算. 就像无符号的加法一样. 只是在加法的数位上的值的解释上有所区别. 特别是要理解为溢出的时候该怎么去定义符号位的行为. 而这些都定义好后. 整个补码的加法的含义有了正确的定义.同时这个操作与无符号的加法的操作完全一致.只是解释不一样而已.

上面有些部分没有深入的展开推导每一种可能的case. 但是原理一样的.不知道你是否学会了呢.

一个知友问的，回答到这里方便更多人看到。

有不对请指正，有细节没写全请脑补~。

“码”和“数”是两个东西。

我们平时说出或写出某“数”，一般都是在十进制下，用10个不同的“码”（此处的“码”还和原码补码反码的概念不同）来表示。分别是0~9。超过9，也就是比最大的码还大的数，采用进位的方式来表示。于是有了“位”的概念。即个位，十位，百位等等。

表达负数的时候由于为了与算术和代数符号当中减号或作差相互兼容，就在该数前面加上减号。

这种对一个数的写法也可以被名门为一种编码方式。在这种编码方式下每个数都有一定的“位数”，即“长度”。在计算机当中规定一定的位数称作“字长”，比如4位，8位，16位，32位等等。只不过，计算机的物理存储数据是二进制方式。我们人类目前传统的还是比较喜欢用10进制方式。并且，我们人类一般不会在书写数字的时候遇到“字长”的概念。但是在念数字和记录数据的时候，有一点点东西跟字长相关。比如西方爱把数据分成三位一组三位一组的方式，觉得比较好记忆。比如12'000读成十二千，我们中国人爱以“万”为字长，1'2000，读作一万二千。举这个例子表示字长的概念不是很恰当。因为对人而言这只是一种表达习惯。但是对机器而言，“字长”则是计算的长度单位。设计计算机进行最简单的加法运算，首先要考虑的就是加法器进行一次加法运算，位数是多长？加法器设计成多少位的加法器？等等。这就是计算机的字长。它和编码方式一起，构成了计算机进行计算的基础。

有了字长的概念才好说补码。

在十进制下也有补码的概念。插一句，谈到补码一定要先明确字长的长度。

补码是用来表示负数的一种编码方式。也是为了在计算机的核心加法器部分的设计避免减法操作，存储数据的时候避免存储负号。

举个例子，假如我们模拟一个字长为4位的十进制计算机。（假设有某种机制，可以在1位上有10种稳定的状态）

对两个数进行求和运算：1234 和 -1234

如果用原码，那么我们需要用一个1位的寄存器来存储和表示负号。假设就在4位的最左边的最高位前用1表示负号，0表示正号。

则，原码表示上面两个数：

0 1234

1 1234

然后计算机做求和，做加法的过程中。计算机发现，其中有一个数是负数，于是要切换为两个正数相减的模式来运算。这很不方便。

于是，补码被想出来了。

\-1234和正1234相加不是等于0000吗？在4位的字长当中的数，和1234相加为0000的，是不是唯一的一个数哪？很明显8766和1234相加等于1'0000，后4位是0000。

那么，8766就可以看着是-1234的一种编码表示方式，被称作“补码”。

所以，补码就是把数1234在一个字长内，补足为1'0000的数的编码方式。也就是一个正数的相反数，在计算机内的表达方式。

加上符号位，正数0'1234的相反数的补码表示就是1'8766。

十进制里，-1234的反码就是1'8765

所以，现在回到4位字长的2进制计算机里来看。补码和反码的构成方式是一样的。0'0001的相反数是-1。

补码表示1'1111

反码表示1'1110

看出补码与反码的区别了吗？

反码就是正数的原码的相反数的一种构成方式（正数本身的反码就是它本身，这里说的是负数的情况），构成方法是按照原码码元逐位取反。在十进制里，取反是个难以延伸的概念，其实是以最大的码元9来减。

补码就是正数的原码的相反数的另一种编码方式。它能把字长内的正数，补足为全是0。

全爪机手打，有点累~

其实也没什么数学原理，主要是因为实现的代价小。在整型数字系统中，能处理算术溢出就差不多了（溢出标志，当然还有其它标志）。

> 模256下的加减法，用0, 1, 2, …, 254, 255表示其值，或者用-128, -127, …, -1, 0, 1, 2, …,127是完全等价的。-128与128，-127与129，…，-2与254，-1与255可以互换而加减法的结果不变。从而，把8位（octet）的高半部分（即二进制的1000 0000到1111 1111）解释为-128到-1，同样也实现了模256的加减法，而且所需要的CPU加法运算器的电路实现与8位无符号整数并无不同。 实际上对于8比特的存储单元，把它的取值\[00000000, 11111111\]解释为\[0, 255\],或者\[0, 254\]、\[-1\]，或者\[0, 253\]、\[-2, -1\]，或者\[0, 127\]、\[-128, -1\]，或者\[0, 55\]、\[-200, -1\]对于加法硬件实现并无不同。

而补码可以表示与正数几乎相同数目的负数。

具体的过程可以看CSAPP第二章。以下节选：

![](https://pic1.zhimg.com/50/v2-7e0d51a4da1c629a61e4127231979a02_720w.jpg?source=1def8aca)

[https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E4%25BA%258C%25E8%25A3%259C%25E6%2595%25B8)

补码的代数原理在这页下半部分：[补码\_百度百科](https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%25E8%25A1%25A5%25E7%25A0%2581)

要特别注意的是，所谓补码符号位直接参与运算自动得到正确结果是有前提条件的，这个条件就是**不溢出**。

溢出的定义有三种，最好理解的是：两个符号相同的补码数相加，如果和的符号与加数的符号相反，或两个符号相反的补码数相减，差的符号与减数的符号相同，都属于运算结果溢出。

溢出了怎么办？溢出后代数结果已经不可能正确了，为了合理解释加法电路的结果，我们定义这个结果的数学含义是“代数结果在定义区间‘-128--127’内的补数”。

补码其实源自补数，而补数是一个变减法为加法的小技巧，有的小学课本里会讲

我们考虑十进制下的两位数减法

比如 21 - 7 = 14

个位不够减，需要借一位，这是有点麻烦的，尤其是对小学生来讲

7 + 93 = 100

我们定义93是7对于100的补数

于是

21 - 7 = 21 - ( 100 - 93) = 21 + 93 - 100 = 114 -100 = 14

也就是说，两位数的减法，可以先求出补数，然后被减数加上补数，再直接去掉溢出位，就得到差了。

知道这个利用补数做减法的技巧，就很容易理解补码了。

这是我今天偶然在一本英文书上读到的，很奇怪，大部分书讲补码的时候从来不讲这个，让初学者不好理解。

如果一本书你看不懂，一门课你学不会，大多数情况下都不是你太笨，而是写书的人不会写，教书的人不会教。

补码 反码这些东西真的很厉害 包括二进制也很厉害 能想到的人 都是天天天才

没什么复杂的数学原理

就跟钟表上的时针往前拨和往后拨可以等价一样

前提是有限整数系统

《C++入门详解》附录B(30) 习题：有符号整数三种格式呈现的规律

贴一篇自己的博客吧，原文地址：[https://blog.csdn.net/WUDIxi/article/details/105854112](https://link.zhihu.com/?target=https%3A//blog.csdn.net/WUDIxi/article/details/105854112)

## 1\. 原码与补码

人类习惯于用十进制数进行运算，而计算机的每个位却只有0和1两种状态，换句话说，计算机采用的进制是二进制。

因此，我们面临的第一个问题就是计算机如何用二进制来表示十进制数字。

对于正数而言，可以直接用该数的二进制形式来表示，例如，十进制数2，其在计算机中的表示为（假设计算机的字长为8）：

但是这样做会带来一个问题，如何表示负数呢？为此，我们采用牺牲最高位的办法，将其视作符号位，并用1表示负，0表示正（这样做是可以接受的，因为虽然正数的表示范围由之前的 \[1, 255\] 缩小到了现在的 \[1, 127\], 但是我们却因此收获了 \[-127, -1\] 的负数表示范围；另一方面，引入符号位后，\[1, 127\] 内的正数的表示方式并没有发生改变，换句话说，引入符号位前后，正数的表示方法是相洽的）。

例如，十进制数-2，其二进制表示现在变为：

这里，我们便可以引入原码的概念

> **原码**：原码是指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1。\[1\]

原码很直观，人类可以直接理解原码。

但是原码是不是完美的呢？很显然，它是有缺陷的。

1）十进制数0的原码并不唯一，以下两个都是0的原码。

2）当进行有负数参与的运算时，原码将暴露更大的缺陷，例如：-3+2：

```text
  1000 0011 #-3的原码
+ 0000 0010 #2的原码
------------
  1000 0101 #-5的原码
```

我们得到了-5，这显然是个错误结果。

为此，我们需要介绍补码这个新概念

> **补码**：正数和0的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加1。\[2\]

例如，2的补码即为：

\-2的补码为：

```text
# 1. 将-2对应的正数2，按位取反得到：1111 1101
# 2. 1111 1101再加1即得到： 1111 1110，为-2的补码
1111 1110
```

0的补码只有一个，为：

现在我们再来验证一下补码在进行加减运算时是否能得到正确结果，同样是-3+2：

```text
  1111 1101  #-3的补码
+ 0000 0010  #2的补码
------------
  1111 1111  #-1的补码
```

可以看到，我们得到了正确答案。

事实上，补码是计算机真正用来表示二进制数的方式，验证如下：

```cpp
#include<iostream>
using std::cout;

int main()
{
	unsigned int a = -1;
	cout << a;  //输出结果为255，即1111 1111， 而1111 1111正是-1的补码
	return 0;
}
```

## 2\. 为什么补码能起作用？

我们知道数轴上的点与实数是一一对应的，先来看看我们最熟悉的十进制数在数轴上的排列：

![](https://pic1.zhimg.com/50/v2-8125ce5b883667c3dcb4c1b4263e8481_720w.jpg?source=1def8aca)

因此，对于数轴上的任意一个数，其加上一个正数，则表示其在数轴正方向上移动了一段距离；而减去一个正数（等价于加上一个负数），则表示其在数轴负方向移动了一段距离。这是确保我们在进行数的加减时得到正确结果的关键。

当我们引入了原码，那么数在数轴上又是如何排列的呢，可以验证，它们的排列变成了下面这个样子：

![](https://picx.zhimg.com/50/v2-3f26d650c4a5b9a97b4cd4e5e80e38e0_720w.jpg?source=1def8aca)

**注意**：0在这里是一个关键的分界线，对于负数而言，它们的“0” 是1000 0000；而对于正数而言，它们的“0”是0000 0000。

仔细观察，我们会发现，这个数轴有两个正方向（这里我们把加上一个正数，数字移动的方向定为正方向）：当一个负数加上一个正数，数字往左边移动，例如：-3+2，结果变成了-5；当一个正数加上一个正数，数字往右边移动，例如3+2，我们得到5. 这就解释了为什么原码在加减运算中会出错的原因。

回到补码，如前所述，一个负数的补码就是是将其对应正数按位取反再加1。但是这里对于补码的叙述并不直观，甚至会让人有点摸不着头脑，为了更好地理解补码究竟在做什么，我们不妨将-2的补码与其对应正数2的补码相加，看看会得到什么结果：

```ps1con
  0000 0010  # 2的补码
+ 1111 1110  #-2的补码
------------
1 0000 0000 
```

这样，我们就发现了对一个负数求补码的本质：

> 负数A\_补 = 模-绝对值（A）

模的值，等于 2^n ，n为字长。例如，对-2求补码：

```text
-2补= 2^8 - 0000 0010#2的补码
    = 10000 0000 - 0000 0010
    = (1111 1111 - 0000 0010) + 1
    #即等于2先按位取反，再加1
```

因此，引入补码后，数字在数轴上的排列变成了下面这个样子：

![](https://pic1.zhimg.com/50/v2-8125ce5b883667c3dcb4c1b4263e8481_720w.jpg?source=1def8aca)

这里，不仅0只有一个表示，而且数轴也只有唯一一个正方向，从而保证了运算的正确性。而这个保证，仔细思考一下就会发现，正是利用了负数A的绝对值与其补码之和等于模，从而将负数部分的数轴方向调转。

注：考虑到计算机存在“**溢出**”的现象，因此更为正确的表示应该采用数环，而不是数轴，不过，理解用的话，数轴足够了。

## 3\. 总结

1\. 为什么要引入补码？

答： 1. 0的原码有两个，处理起来不方便；2. 原码不能直接相加减；

2\. 引入补码的好处？

答：1. 0的补码只有一个；2. 变减法为加法，即减法和加法共用一套底层电路；3. 补码之间可以直接相加减，最高位可以接受进位。

## 参考

\[1\] [https://zh.wikipedia.org/wiki/原码](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%258E%259F%25E7%25A0%2581)

\[2\] [https://zh.wikipedia.org/wiki/补码](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25A1%25A5%25E7%25A0%2581)